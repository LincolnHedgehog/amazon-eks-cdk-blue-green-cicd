pipeline {
  agent {
    label 'build-slave1'
  }
  stages {
    stage('test') {
      steps {

        withCredentials([[ $class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'e4e458ba-8178-4cc7-af47-cbd9046e76ce', accessKeyVariable: 'AWS_ACCESS_KEY_ID', secretKeyVariable: 'AWS_SECRET_ACCESS_KEY']]) {
              sh "echo this is ${env.AWS_ACCESS_KEY_ID}"
              sh "echo this is ${env.AWS_SECRET_ACCESS_KEY}"
              sh "aws s3 ls"
        }

      }
    }
    stage ('Pre-Build Stage') {
      steps {

        withCredentials([[ $class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'e4e458ba-8178-4cc7-af47-cbd9046e76ce', accessKeyVariable: 'AWS_ACCESS_KEY_ID', secretKeyVariable: 'AWS_SECRET_ACCESS_KEY']]) {
              sh "echo this is ${env.AWS_ACCESS_KEY_ID}"
              sh "echo this is ${env.AWS_SECRET_ACCESS_KEY}"
              sh "aws s3 ls"
        }

        sh label: '', script: '''echo "==================="
        echo "Pre-Build Stage"
        echo "==================="
        export ACCOUNT_ID=$(aws sts get-caller-identity --output text --query Account)
        echo "The AWS Region is set to: ${JENKINS_AWS_REGION}"
        aws configure set region ${JENKINS_AWS_REGION}
        export AWS_REGION=$(aws configure get region)


        kubectlcmd=$(aws cloudformation --region ${AWS_REGION} describe-stacks --stack-name CdkStackALBEksBg | jq \'.Stacks[].Outputs[1].OutputValue\' | tr -d \'"\')
        eval $kubectlcmd
        kubeClusterName=$(aws cloudformation --region ${AWS_REGION} describe-stacks --stack-name CdkStackALBEksBg | jq \'.Stacks[].Outputs[0].OutputValue\' | tr -d \'"\')
        kubectl get nodes
        ecrRepo=$(aws cloudformation --region ${AWS_REGION} describe-stack-resources --stack-name CdkStackALBEksBg | jq \'.StackResources[]|select(.ResourceType == "AWS::ECR::Repository").PhysicalResourceId\' | tr -d \'"\')
        preEcrRepo="${ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/"
        ECR_REPO_URI=$preEcrRepo$ecrRepo
        echo $ECR_REPO_URI

        export CLUSTER_NAME=$kubeClusterName
        export ECR_REPO_URI=$ECR_REPO_URI

        #CODEBUILD_RESOLVED_SOURCE_VERSION=$(git rev-parse HEAD)
        CODEBUILD_RESOLVED_SOURCE_VERSION=01234abcdefgh
        export TAG=${CODEBUILD_RESOLVED_SOURCE_VERSION}'''
      }
    }
    stage ('Build Stage') {
      steps {
        sh label: '', script: '''echo "==================="
        echo "Build Stage"
        echo "==================="

        pwd
        ls -al
        cd amazon-eks-cicd-codebuild-eks-alb-bg/flask-docker-app
        aws configure set region ${AWS_REGION}
        $(aws ecr get-login --no-include-email)
        docker build -t $ECR_REPO_URI:$TAG .
        docker push $ECR_REPO_URI:$TAG
        '''
      }
    }
    stage ('Post-Build Stage') {
      steps {
        sh label: '', script: '''echo "==================="
        echo "Post-Build Stage"
        echo "==================="

        kubectl get nodes -n flask-alb
        kubectl get deploy -n flask-alb
        kubectl get svc -n flask-alb
        isDeployed=$(kubectl get deploy -n flask-alb -o json | jq \'.items[0]\')
        deploy8080=$(kubectl get svc -n flask-alb -o wide | grep 8080: | tr \' \' \'\\n\' | grep app= | sed \'s/app=//g\')
        echo $isDeployed $deploy8080

        if [[ \\"$isDeployed\\" == \\"null\\" ]]; then kubectl apply -f k8s/flaskALBBlue.yaml && kubectl apply -f k8s/flaskALBGreen.yaml; else kubectl set image deployment/$deploy8080 -n flask-alb flask=$ECR_REPO_URI:$TAG; fi

        kubectl get deploy -n flask-alb
        kubectl get svc -n flask-alb
        '''
      }
    }

  }
}
